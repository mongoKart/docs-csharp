.. _csharp-serialize-bson:


==============
Serialize BSON
==============

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Overview
--------

In the {+driver-long+}, **:wikipedia:`serialization <Serialization>`** is the process of 
mapping a {+language+} object to a BSON document. Reading and Writing BSON/JSON 
demonstrates how to manually read and write BSON and JSON. However, using the 
serialization classes make this process much easier.

Use a Serializer
----------------

The {+driver-short+} includes serializers for primitive types, collection types, 
and some custom classes. 

The following code sample shows how to use the provided ``BsonDocumentSerializer`` class 
to read a BSON document from a file into a ``BsonDocument`` object:

.. code-block:: csharp

   string inputFileName = "myFile.bson";

   using (var stream = File.OpenRead(inputFileName))
   using (var reader = new BsonReader(inputFileName))
   {
       var context = BsonDeserializationContext.CreateRoot(reader);
       BsonDocument doc = BsonDocumentSerializer.Instance.Deserialize(context);
   }

Create a Serializer
-------------------

.. warning::
   Because there are often unexpected edge cases to handle, writing custom serializers 
   can be challenging. 

To create a custom serializer, define a class that inherits from ``SerializerBase<T>``
and override the ``Serialize`` and ``Deserialize`` methods. 

In the following code sample, the ``MyInt32Serializer`` class serializes and deserializes
``int`` values. The class inherits from ``SerializerBase<int>`` and overrides the 
``Serialize`` and ``Deserialize`` methods.

.. code-block:: csharp

    class MyInt32Serializer : SerializerBase<int>
    {
        public override void Serialize(BsonSerializationContext context, BsonSerializationArgs args, int value)
        {
            context.Writer.WriteInt32(value);
        }

        public override int Deserialize(BsonDeserializationContext context, BsonDeserializationArgs args)
        {
            var type = context.Reader.GetCurrentBsonType();
            switch (type)
            {
                case BsonType.Int32:
                    return context.Reader.ReadInt32();
                case BsonType.Int64:
                    return Convert.ToInt32(context.Reader.ReadInt64());
                case BsonType.Double:
                    return Convert.ToInt32(context.Reader.ReadDouble());
                case BsonType.String:
                    return int.Parse(context.Reader.ReadString());
                default:
                    var message = string.Format("Cannot convert a {0} to an Int32.", type);
                    throw new NotSupportedException(message);
            }
        }
    }

In the preceding example, the ``Deserialize`` method provides handling for certain 
data types besides ``Int32``.
If the value is an ``Int64``, ``double``,
or ``string``, the method converts the value to an ``Int32`` before deserializing it.

.. warning::
   Converting one data type to another can cause an overflow or truncation, which may 
   result in an exception.

.. tip::
   The ``Deserialize`` method in the built-in ``Int32Serializer`` class performs type 
   conversation similar to the preceding example.

Serializer Registry
The serializer registry contains all the IBsonSerializers that have been registered. 
It can be accessed via the SerializerRegistry property of the static class BsonSerializer.

.. note::
   The serializer registry is global. You can't use multiple serializer registries in a 
   single application.


Serialization Provider

The serializer registry is backed by a list of IBsonSerializationProvider objects. 
A **serialization provider** is an object that returns a serializer, allowing you to
provide serializers on demand. 

You must register a serialization provider before you can use it.

Implementation
--------------

To create a serialization provider, define a class that implements the 
``IBsonSerializationProvider`` interface. This interface requires
one method, ``GetSerializer``, that returns a serializer for every type you're able
to handle and ``null`` for any type your provider isn't prepared to handle. 

The following code sample shows one way to implement ``IBsonSerializationProvider``.
If the ``type`` parameter is an ``int`` (the type to be serializer is an integer),
the ``GetSerializer`` method returns an instance of ``MyInt32Serializer``. If ``type``
is any other type, the method returns ``null`` and the next ``IBsonSerializationProvider``
handles the request. 

.. code-block:: csharp
    
   class MyProvider : IBsonSerializationProvider
   {
       public IBsonSerializer GetSerializer(Type type)
       {
           if (type == typeof(int))
           {
               return new MyInt32Serializer();
           }        

           return null;
       }
   }

}

You can register your serializer using the RegisterSerializer or implement a 
serialization provider.

Opt-in Interfaces
There are some opt-in interfaces that allow the driver to utilize your custom serializer in special ways. You should evaluate these interfaces and decide whether your serializer should implement them.

IBsonIdProvider
If your class is used as a root document, you should implement the IBsonIdProvider interface in order for "Inserting" the document to function best, especially if the class your serializer is for uses an Id type other than ObjectId.

IBsonDocumentSerializer
In order to enable the driver to properly construct type-safe queries using a custom serializer, it needs access to member information. If your custom serializer is for a class, then you should implement IBsonDocumentSerializer.

class MyClass
{
    public ObjectId Id { get; set; }

    public string FirstName { get; set; }

    public string LastName { get; set; }
}

class MyClassSerializer : SerializerBase<MyClass>, IBsonDocumentSerializer
{
    // implement Serialize and Deserialize

    public bool TryGetMemberSerializationInfo(string memberName, out BsonSerializationInfo serializationInfo)
    {
        switch (memberName)
        {
            case "Id":
                serializationInfo = new BsonSerializationInfo("_id", new ObjectIdSerializer(), typeof(ObjectId));
                return true;
            case "FirstName":
                serializationInfo = new BsonSerializationInfo("fn", new StringSerializer(), typeof(string));
                return true;
            case "LastName":
                serializationInfo = new BsonSerializationInfo("ln", new StringSerializer(), typeof(string));
                return true;
            default:
                serializationInfo = null;
                return false;
        }
    }
}
Above, we are providing information about the members of our class based on the member name. This enables the driver to, for instance, translate the below lambda expression into { fn: 'Jack' }.

Find(x => x.FirstName == "Jack")
IBsonArraySerializer
In the same way, if you have written a custom collection serializer, you should implement IBsonArraySerializer.

The serializer registry for the driver is global.
It's basically a list of available serialization providers for particular types.
The driver can auto-map types and add them to the registry. When a serialzier is needed,
the driver walks up the type hierarchy in the registry to find an appropriate provider.
If you want custom serialization, you can pre-empt the default serializer by 
manually registering one yourself.

When a serializer is needed for a specific type, the driver checks the registry for a matching provider.
If one isn't found, it walks through the available providers to find one, then registers
and caches it.

Custom serializatio is discouraged, but is a kind of escape hatch if none of the 
built-in serializers work. FOr example, perhaps values for a specific field aren't 
consistent in the database, in which case the default serializer may not work.

There is no list of availabler serializers, except in the source code.

You would use reader/writer mainly (only?) when creating your own serializer.

Most of the time, default serializers work--you can add class maps/attributes if needed.
Would do this programmatically only when needed.

First option: Auto-mapping
Second option: Add attributes to override (e.g., store enum as string)
Third option: Create Class maps in code
Fourth option: Define your own Custom Bson Serializer